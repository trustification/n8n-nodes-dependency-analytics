import type { IExecuteFunctions, INodeExecutionData, IHttpRequestOptions } from 'n8n-workflow';
import { authedRequest, chooseCredential, defaultJsonHeaders, getBase } from '../utils/http';
import { parsePurls } from '../utils/parsePurls';
import { throwError } from '../utils/errors';
import { multiCmp, SortRule } from '../utils/sort';
import { readSortRules } from '../utils/readSort';
import { shapeOutput } from '../utils/output';

export async function get({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const identifierRaw = (ctx.getNodeParameter('identifier', itemIndex, '') as string).trim();
  if (!identifierRaw)
    throwError(ctx.getNode(), "The 'Identifier' parameter is required.", itemIndex);

  const options: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/vulnerability/${encodeURIComponent(identifierRaw)}`,
    returnFullResponse: false,
    headers: defaultJsonHeaders,
  };

  const res = await authedRequest(ctx, credentialName, options);
  return shapeOutput(ctx, itemIndex, 'vulnerability', res);
}

export async function getMany({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const limit = (ctx.getNodeParameter('limit', itemIndex, 50) as number) || 50;

  const options: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/vulnerability`,
    qs: { limit },
    returnFullResponse: false,
    headers: defaultJsonHeaders,
  };

  const res = (await authedRequest(ctx, credentialName, options)) as any;
  const items: any[] = Array.isArray(res?.items) ? res.items : [];
  const rules: SortRule[] = readSortRules(ctx, itemIndex, 'vulnerability');

  let out = items;
  if (rules.length) out = [...out].sort((a, b) => multiCmp(a, b, rules));

  out = out.slice(0, limit);

  const finalItems = out.map((it) => shapeOutput(ctx, itemIndex, 'vulnerability', it));
  return [{ json: { ...res, items: finalItems } }];
}

export async function analyze({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const inputType = ctx.getNodeParameter('inputType', itemIndex) as 'sbomSha256' | 'purls';

  if (inputType === 'purls') {
    const raw = ctx.getNodeParameter('purlsRaw', itemIndex) as unknown;
    const purls = parsePurls(raw, ctx, itemIndex);
    if (purls.length === 0)
      throwError(ctx.getNode(), "Provide at least one PURL in 'PURLs'.", itemIndex);

    const options: IHttpRequestOptions = {
      method: 'POST',
      url: `${base}/vulnerability/analyze`,
      body: { purls },
      json: true,
    };

    try {
      const res = await authedRequest(ctx, credentialName, options);
      return [{ json: res } as INodeExecutionData];
    } catch (err: any) {
      if (ctx.continueOnFail()) {
        return [{ json: { message: err.message, request: { purls } } } as INodeExecutionData];
      }
      throw err;
    }
  }

  // inputType === 'sbomSha256'
  const q = (ctx.getNodeParameter('sbomSha256', itemIndex) as string)?.trim();
  if (!q) throwError(ctx.getNode(), "The 'SBOM SHA-256' parameter is required.", itemIndex);

  // SBOM by sha256
  const listOpts: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/sbom/sha256:${q}`,
    qs: { query: q },
    returnFullResponse: false,
  };

  const listResp = (await authedRequest(ctx, credentialName, listOpts)) as any;
  const sbomId = listResp?.id;
  if (!sbomId)
    throwError(ctx.getNode(), "No SBOM found for the provided value in 'SBOM SHA-256'.", itemIndex);

  // Advisories for SBOM
  const advOpts: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/sbom/${encodeURIComponent(sbomId)}/advisory`,
    returnFullResponse: false,
  };

  const advisories = await authedRequest(ctx, credentialName, advOpts);

  return [{ json: { sbomId, advisories } } as INodeExecutionData];
}
