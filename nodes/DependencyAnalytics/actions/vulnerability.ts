import type { IExecuteFunctions, INodeExecutionData, IHttpRequestOptions } from 'n8n-workflow';
import { authedRequest, chooseCredential, defaultJsonHeaders, getBase } from '../utils/http';
import { parsePurls } from '../utils/parsePurls';
import { throwError } from '../utils/errors';
import { multiCmp, SortRule } from '../utils/sort';
import { readSortRules } from '../utils/readSort';
import { shapeOutput } from '../utils/output';

export async function get({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const identifierRaw = (ctx.getNodeParameter('identifier', itemIndex, '') as string).trim();
  if (!identifierRaw)
    throwError(ctx.getNode(), "The 'Identifier' parameter is required.", itemIndex);

  const options: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/vulnerability/${encodeURIComponent(identifierRaw)}`,
    returnFullResponse: false,
    headers: defaultJsonHeaders,
  };

  const res = await authedRequest(ctx, credentialName, options);
  return shapeOutput(ctx, itemIndex, 'vulnerability', res);
}

export async function getMany({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const limit = (ctx.getNodeParameter('limit', itemIndex, 50) as number) || 50;

  const options: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/vulnerability`,
    qs: { limit },
    returnFullResponse: false,
    headers: defaultJsonHeaders,
  };

  const res = (await authedRequest(ctx, credentialName, options)) as any;
  const items: any[] = Array.isArray(res?.items) ? res.items : [];
  const rules: SortRule[] = readSortRules(ctx, itemIndex, 'vulnerability');

  let out = items;
  if (rules.length) out = [...out].sort((a, b) => multiCmp(a, b, rules));

  out = out.slice(0, limit);

  const finalItems = out.map((it) => shapeOutput(ctx, itemIndex, 'vulnerability', it));
  return [{ json: { ...res, items: finalItems } }];
}

export async function analyze({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
  const credentialName = chooseCredential(ctx, itemIndex);
  const base = getBase(ctx, itemIndex);
  const inputType = ctx.getNodeParameter('inputType', itemIndex) as 'sbomSha' | 'purls';

  if (inputType === 'purls') {
    const raw = ctx.getNodeParameter('purlsRaw', itemIndex) as unknown;
    const purls = parsePurls(raw, ctx, itemIndex);
    if (purls.length === 0)
      throwError(ctx.getNode(), "Provide at least one PURL in 'PURLs'.", itemIndex);

    const options: IHttpRequestOptions = {
      method: 'POST',
      url: `${base}/vulnerability/analyze`,
      body: { purls },
      json: true,
    };

    try {
      const res = (await authedRequest(ctx, credentialName, options)) as any;

      const rules: SortRule[] = readSortRules(ctx, itemIndex, 'vulnerability');
      const mode = ctx.getNodeParameter('outputMode', itemIndex, 'simplified') as
        | 'simplified'
        | 'raw'
        | 'selected';

      // Build enriched advisories with vulnerability fields and originating package (purl)
      const enrichedAdvisories: any[] = [];

      const isPlainObject = (v: any) => v && typeof v === 'object' && !Array.isArray(v);
      if (isPlainObject(res)) {
        for (const [pkgPurl, data] of Object.entries(res as Record<string, any>)) {
          const details = Array.isArray(data)
            ? (data as any[])
            : Array.isArray((data as any)?.details)
              ? (data as any).details
              : [];
          if (details.length === 0 && Array.isArray((data as any)?.advisories)) {
            // Fallback: direct advisories array
            for (const adv of (data as any).advisories as any[]) {
              enrichedAdvisories.push({ ...adv, package: pkgPurl });
            }
          }
          for (const d of details) {
            const affected = (d as any)?.status?.affected;
            if (Array.isArray(affected)) {
              for (const adv of affected) {
                // Merge advisory with vulnerability-level fields and the originating package
                enrichedAdvisories.push({
                  ...adv,
                  package: pkgPurl,
                  normative: (d as any)?.normative ?? (d as any)?.status?.normative ?? null,
                  identifier: (d as any)?.identifier ?? adv?.identifier ?? null,
                  title: (d as any)?.title ?? adv?.title ?? null,
                  description: (d as any)?.description ?? null,
                  reserved: (d as any)?.reserved ?? null,
                  published: (d as any)?.published ?? adv?.published ?? null,
                  modified: (d as any)?.modified ?? adv?.modified ?? null,
                  withdrawn: (d as any)?.withdrawn ?? adv?.withdrawn ?? null,
                  discovered: (d as any)?.discovered ?? null,
                  released: (d as any)?.released ?? null,
                  cwes: (d as any)?.cwes ?? adv?.cwes ?? null,
                  status: (d as any)?.status ?? null,
                });
              }
            }
          }
        }
      } else {
        // Fallback to previous generic flattening while trying to retain package
        const buckets: any[] = Array.isArray(res)
          ? res
          : Array.isArray(res?.items)
            ? res.items
            : Array.isArray(res?.vulnerabilities)
              ? res.vulnerabilities
              : [res];

        for (const bucket of buckets) {
          if (bucket && typeof bucket === 'object') {
            if (Array.isArray((bucket as any).advisories)) {
              for (const adv of (bucket as any).advisories as any[]) {
                const pkg = (adv as any)?.packages?.[0]?.purl ?? null;
                enrichedAdvisories.push({ ...adv, package: pkg });
              }
              continue;
            }
            const candidates: any[] = [];
            if (Array.isArray((bucket as any).details)) candidates.push(bucket);
            for (const v of Object.values(bucket)) {
              if (v && typeof v === 'object') candidates.push(v);
            }
            for (const cand of candidates) {
              const details = Array.isArray((cand as any)?.details) ? (cand as any).details : [];
              for (const d of details) {
                const affected = (d as any)?.status?.affected;
                if (Array.isArray(affected)) {
                  for (const adv of affected) {
                    const pkg =
                      (d as any)?.status?.packages?.[0]?.purl ??
                      (adv as any)?.packages?.[0]?.purl ??
                      null;
                    enrichedAdvisories.push({
                      ...adv,
                      package: pkg,
                      normative: (d as any)?.normative ?? (d as any)?.status?.normative ?? null,
                      identifier: (d as any)?.identifier ?? adv?.identifier ?? null,
                      title: (d as any)?.title ?? adv?.title ?? null,
                      description: (d as any)?.description ?? null,
                      reserved: (d as any)?.reserved ?? null,
                      published: (d as any)?.published ?? adv?.published ?? null,
                      modified: (d as any)?.modified ?? adv?.modified ?? null,
                      withdrawn: (d as any)?.withdrawn ?? adv?.withdrawn ?? null,
                      discovered: (d as any)?.discovered ?? null,
                      released: (d as any)?.released ?? null,
                      cwes: (d as any)?.cwes ?? adv?.cwes ?? null,
                      status: (d as any)?.status ?? null,
                    });
                  }
                }
              }
            }
          }
        }
      }

      let out = enrichedAdvisories;

      if (rules.length) out = [...out].sort((a, b) => multiCmp(a, b, rules));

      const limit = (ctx.getNodeParameter('limit', itemIndex, 50) as number) || 50;
      out = out.slice(0, limit);

      // RAW mode: return flattened advisories under a consistent key
      if (mode === 'raw') {
        return [{ json: { advisories: out } } as INodeExecutionData];
      }

      // Simplified: project minimal advisory fields locally to avoid advisory-specific simplifier
      if (mode === 'simplified') {
        const simplified = out.map((a: any) => ({
          uuid: a?.uuid ?? null,
          normative: a?.normative ?? null,
          identifier: a?.identifier ?? null,
          document_id: a?.document_id ?? null,
          package: a?.package ?? null,
          title: a?.title ?? null,
          description: a?.description ?? null,
          score: a?.score ?? null,
        }));
        return [{ json: { advisories: simplified } } as INodeExecutionData];
      }

      // Selected: use generic advisory shaper
      const finalItems = out.map((it) => shapeOutput(ctx, itemIndex, 'advisory', it));
      return [{ json: { advisories: finalItems } } as INodeExecutionData];
    } catch (err: any) {
      if (ctx.continueOnFail()) {
        return [{ json: { message: err.message, request: { purls } } } as INodeExecutionData];
      }
      throw err;
    }
  }

  const q = (ctx.getNodeParameter('sbomSha', itemIndex) as string)?.trim();
  if (!q) throwError(ctx.getNode(), "The 'SBOM SHA' parameter is required.", itemIndex);
  if (!/^sha(?:256|384|512):[a-f0-9]+$/i.test(q)) {
    throwError(
      ctx.getNode(),
      "Provide 'SBOM SHA' with a prefix: sha256:, sha384:, or sha512:.",
      itemIndex,
    );
  }

  const listOpts: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/sbom/${encodeURIComponent(q)}`,
    returnFullResponse: false,
  };

  const listResp = (await authedRequest(ctx, credentialName, listOpts)) as any;
  const sbomId = listResp?.id;
  if (!sbomId)
    throwError(ctx.getNode(), "No SBOM found for the provided value in 'SBOM SHA'.", itemIndex);

  // Advisories for SBOM
  const advOpts: IHttpRequestOptions = {
    method: 'GET',
    url: `${base}/sbom/${encodeURIComponent(sbomId)}/advisory`,
    returnFullResponse: false,
  };

  const advisories = (await authedRequest(ctx, credentialName, advOpts)) as any;

  const rules: SortRule[] = readSortRules(ctx, itemIndex, 'vulnerability');
  let out = advisories;
  if (Array.isArray(advisories) && rules.length) {
    out = [...advisories].sort((a, b) => multiCmp(a, b, rules));
  }

  const limit = (ctx.getNodeParameter('limit', itemIndex, 50) as number) || 50;
  if (Array.isArray(out)) out = out.slice(0, limit);

  const mode = ctx.getNodeParameter('outputMode', itemIndex, 'simplified') as
    | 'simplified'
    | 'raw'
    | 'selected';

  // RAW mode: return advisories as-is under a consistent key
  if (mode === 'raw') {
    return [
      { json: { sbomId, advisories: Array.isArray(out) ? out : [out] } } as INodeExecutionData,
    ];
  }

  // Simplified mode: custom sbom-sha advisory projection per user requirements
  if (mode === 'simplified') {
    const simplified = (Array.isArray(out) ? out : [out]).map((item: any) => {
      const toScores = (scores: any) => (Array.isArray(scores) ? scores : null);
      const statusArr = Array.isArray(item?.status)
        ? item.status.map((s: any) => ({
            normative: s?.normative ?? null,
            identifier: item?.identifier ?? null,
            title: s?.title ?? null,
            description: s?.description ?? null,
            averageSeverity: s?.average_severity ?? null,
            averageScore: s?.average_score ?? null,
            status: s?.status ?? null,
            packages: s?.packages ?? null,
            score: toScores(item?.scores) ?? toScores(s?.scores),
          }))
        : [];
      return {
        uuid: item?.uuid ?? null,
        identifier: item?.identifier ?? null,
        title: item?.title ?? null,
        status: statusArr,
      };
    });

    return [{ json: { sbomId, advisories: simplified } } as INodeExecutionData];
  }

  // Selected fields mode: reuse normal advisory shaping
  const shaped = Array.isArray(out)
    ? out.map((it: any) => shapeOutput(ctx, itemIndex, 'advisory', it))
    : shapeOutput(ctx, itemIndex, 'advisory', out);

  return [
    {
      json: { sbomId, advisories: Array.isArray(shaped) ? shaped : [shaped] },
    } as INodeExecutionData,
  ];
}
